import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark } from "@code-surfer/themes";
import NotesCodeSurfer from "./src/NotesCodeSurfer";

export const theme = vsDark;

# Hello ðŸ‘‹

You are using [MDX Deck](https://github.com/jxnblk/mdx-deck) and [Code Surfer](https://codesurfer.pomb.us)

---

<NotesCodeSurfer>

```notes checkout:react-local-state/1
Before we start coding, let's get familiar with
the code that Matt -our awesome product designer-
has prepared for us. Here we have the root
component, which has two main sections:

- The Orders component
- And the Currencies

and then, here in the middle: we have a button
for adding orders and these OrderTotal component
which renders the total sum of the
base-currency-price of the orders.

Perfect! Now, let's have a quick look at
the Orders and the Currencies
```

```jsx 86:97 file="./codeblocks/react/01_startingpoint.tsx"
App;
```

```notes
The Orders component is just a Table that
renders the different Orders, using the
OrdersLine Component.

Also, we notice that the initial orders are
currently hardcoded and they com from the
initialOrders which is imported from the utils
file.
```

```diff 70:78
  Orders
```

```notes
The Orderline component: very straightforward.
It gets an Order through props and it renders
its properties.
Its worth noting, though, that the base-cc-price,
which is a computed field, is currenctly hardcoded.
```

```diff 55:68
  Orderline
```

```notes
The Currencies Component is almost identical
to the Orders component: just a table with
different columns and it renders a CurrencyRate
row for each currency.

Like with the orders, the currencies are
currently being hardcoded from the
`initialCurrencyRates` also come from the
utils file.
```

```diff 23:32
  Currencies
```

```notes
The CurrencyRate component: this is the one 
that it's used for editting the currencies
and it's also very straightforward:

It renders a currency, and it's rate value,
which can be editted through the NumberInput
component.

Awesome! Now let's start coding!
```

```diff 11:21
```

```notes checkout:react-local-state/2
We have noticed that the currencies are
being used in the 2 main components. So,
this is data that needs to be accessed by
different components at different levels,
let's put use React Context to have them
easily available.

We create a hook to easily access the
currencies, and a CurrenciesProvider that
we will use in our root component.
```

```jsx 12:23 file="./codeblocks/react/02_1currencyContext.tsx"
```

```notes
Let's use the `useCurrencies` hook.
```

```diff 37:46
```

```jsx 37:46 file="./codeblocks/react/02_2currencyContext.tsx"
```

```notes
Again...
```

```diff 48:67
```

```jsx 48:67 file="./codeblocks/react/02_3currencyContext.tsx"
```

```notes
And let's use the CurrenciesProvider
in our root component.

Ok, that wasn't too hard!
```

```diff 100:111
```

```jsx 101,112 file="./codeblocks/react/02_4currencyContext.tsx"
```

```notes
Now lets wire up the
Exchanges Rate section
```

```diff 25:35
```

```notes checkout:react-local-state/3
Easy! Let's keep it simple,
using `useState` should do.

I mean, we shouldn't be lifting
state unless we have to, right?

Look at that! This is working just great,
and without any annoying re-renders
on the components that are not concerned
with the currency that we just updated.

Now  that we are done with
the Exchanges Rate section
let's move on to the Orders
section.
```

```jsx 26,31 file="./codeblocks/react/03_exchangeRate.tsx"
```

```notes
Let's start by wiring up the price
and currency selection of each
order.
```

```diff 69:82
```

```notes checkout:react-local-state/4
And again, a couple of `useState`
here and that's it!

Now let's make sure that this is
working correctly...

Amazing! Look at that: we got ~75% of
the functionality working already.

Ok, now let's wire up the
base-currency-price...

Oh, wait! shut! Mmmm... To calculate
this value we have to access the rate
of the selected currency.

All right, that's ok, we just need to lift
the state of the currency-rates, right?
No big deal... Let's do it.
```

```jsx file="./codeblocks/react/04_orderLinePrice.tsx"
```

```notes
We create another Context for the
currencyRates.
```

```diff 12:23
```

```notes checkout:react-local-state/5
then we create a useCurencyRates hook
to easily access the state of the
currencyRates and a ContextProvider
that we can place in the already
existing Currencies Provider.
```

```jsx 19:23,29,31 file="./codeblocks/react/05_1liftCurrencyRates.tsx"
```

```notes
then we replace the useState with
our `useCurrencyRatesHook` and...
we are done!

Lifting state it's a bit of a pain,
but it's not so bad, right?

Ok, let's make sure that the
currency rates are still working...

Ok, so, they do work, but wait...
Oh, cmon, now every single row re-renders?

Oh, of course, because now every time
that a currency-rate changes the whole
record changes and that triggers
a re-render per each row... Dang!

Ok, there are a number of ways
that we can use to prevent these
re-renders... But I guess that the
simplest in this case is to let
the parent component pass
everything down to the CurrencyRate
component and then use the memo
HOC to prevent the CurrencyRate
component from re-rendering.

All right, all right, let's do
that...
```

```diff 36:46
```

```jsx 37:38,45:47 file="./codeblocks/react/05_2liftCurrencyRates.tsx"
```

```diff 36:63
```

```notes checkout:react-local-state/7
Now the Currencies component
is the one passing down everything
that the CurrencyRate component
needs, and then we ehance
the CurrencyRate component
with `memo` to prevent
re-renders
```

```jsx 36:40,57,60:66 file="./codeblocks/react/06_avoidRerenders.tsx"
```

```notes
We are finally ready
to wire-up the base-ccy-price.
```

```diff 93:108
```

```notes checkout:react-local-state/8
We obtain the currencyRates
from context and then we
can calculate the baseCurrencyPrice
using the getBaseCurrencyPrice
function that's defined in
the utils file.

Let's try it:

Nice, it's working...

Although every time that
we change a currency rate
every single order
re-renders, even when
we change a currency rate
that's not being used...

Of course, because we
are accessing the currencyRates
from the Orderline component
and now every time that
one of the currencies
changes that triggers
a re-render in every
Order...

We could prevent that
if the Orderline Component
received through props
the rate that its relevant
to them. However, in order
to know that, we need to
be able to access from
the outside the selected
currency... So, we should
also lift the state of
the selected currency.

Actually, we will have
to do that anyways, because
I just noticed that we will
need to access the state
of the base-ccy-price from
the outside to compute
the sum...

So, let's lift this state.
```

```jsx 97:98,108 file="./codeblocks/react/07_orderLinePrice.tsx"
```

```notes
Let's add a new context for
the orders, but before we
do that, we will first
create a reducer for
the Orders, because now
it's state is a bit more
complex than just setting
a property. Also, this
will help us to prevent
re-renders, because we
will be able to pass
the `dispatch` down
without createing new
functions.
```

```diff 15:55
```

```notes checkout:react-local-state/9
The reducer is a bit
verbose, but it makes
things easier for the
consumer of dispatch.
```

```jsx 44:80 file="./codeblocks/react/08_1liftOrdersState.tsx"
```

```notes
Now we can create the context
for the orders... As usual
we create a hook for accessing
the orders from context
and a Provider that
we will place in our
root component.
```

```jsx 82:93 file="./codeblocks/react/08_2liftOrdersState.tsx"
```

```notes
Now lets change the Orders
component so that it
accesses the currencies
and the orders from
context and it spoon-feeds
the Orderline Component
```

```diff 171:180
```

```notes
That's it...
```

```jsx 172:173,177:182 file="./codeblocks/react/08_3liftOrdersState.tsx"
```

```notes
And time to make the
Orderline component a lot
dummer.
```

```diff 152:169
```

```notes
Now the Orderline component
receives everythng from props
and the onChange handlers
are a bit more verbose than
before, but that's ok.
```

```jsx 152:156,164:166,172:174 file="./codeblocks/react/08_4liftOrdersState.tsx"
```

```notes
And let's not forget to add
the OrdersProvider
```

```diff 204:217
```

```notes
Alright, now that we've
lifted the state, let's
make sure that we don't have
unwanted re-renders.

Nice!

Now we are finally ready
to make the Add button and
the OrderTotal component
work.
```

```jsx 206,217 file="./codeblocks/react/08_5liftOrdersState.tsx"
```

```notes
Let's start with the Add
button. Ok, so we better
create a component for this
button... Otherwise we
will be triggering re-renders
everywhere every time that
one of the orders change...

I guess that we could have
split the context of the orders
to separate the dispatch from
the state... Maybe next time!
```

```diff 211
```

```notes checkout:react-local-state/10
So, here we have the new
component accessing the
dispatch for creating a new row.

Let's see if it works...

Awesome!
```

```jsx 201:212,226 file="./codeblocks/react/09_addOrderButton.tsx"

```

```notes checkout:react-local-state/11
Almost done! Let's wire
this one up, and that's it...
```

```diff 214:217
```

```notes
So, we access the orders
and the currencyRates and
we map each order to calculate
its base-ccy-price and then
we add them all together
and we are done!

It bothers me a bit that
I have to recalculate the
base-ccy-price per each
order, because we have already
done this in the Orderline
component...

But, how else are we going
to do this using React as
a state-management library?

Create a common reducer
between the currencies and
the orders? So that we can
update the base-ccy-price
every time that one of
them change? That would
be pretty bad...

Should we use a library
like reselect for memoizing
these computations? That
wouldn't work either
because each Order
is a different computation.

Anyways, this does the trick.
```

```jsx file="./codeblocks/react/10_calculateTotal.tsx"

```

</NotesCodeSurfer>

---

# Tree view vs Graph state

---

# Solving the same problem with React-RxJS

---

<NotesCodeSurfer>

```notes checkout:react-rxjs/1
The starting point is the same as before.

And the first thing that we 
did was to put the currencies
in context, right?
```

```jsx 86:97 file="./codeblocks/react-rxjs/01_startingpoint.tsx"
```

```notes checkout:react-rxjs/2
With React-RxJS we can use
bind for accomplishing the
same thing.

Bind is the secrete sauce of
React-RxJS. So, let me explain
what bind does:

Bind is a function that takes
at least one argument:

- The observable that will be emitting
the values that we want to use inside
react.

- The second argument, which is optional,
it's the default value that will
be used until the observable emits.

Then bind returns a tuple with 2
different things:

- A react-hook
- A shared and replayable version
of the input observable. In other
words, the improved version of the
input observable that the hook
is going to be using behind the
scenes.

It's very similar to applying a 
`shareReplay(1)` to the input observable,
but with the difference
that it doesn't create memory-leaks.
because when all it's subscribers
unsubscribe from it, it clears
its state and it unsubscribes from
its source.

Using `bind` here may look like
an overkill, but it has 2 advantages
over using react-context:

1) It's a lot easier to setup.
2) If in the future the currencies
is become a dynamic value, we can
replace the `EMPTY` stream with the
observable of active currencies without
having to change anything else.
```

```jsx 13 file="./codeblocks/react-rxjs/02_1useCurrencies.tsx"
```

```notes
Ok, so let's use the useCurrencies hook.
```

```diff 28
```

```jsx 28 file="./codeblocks/react-rxjs/02_2useCurrencies.tsx"
```

```notes
Same...
``

```diff 42
```

```notes
Now let's wire up the Exchange Rates
```

```jsx 42 file="./codeblocks/react-rxjs/02_3useCurrencies.tsx"
```

```notes checkout:react-rxjs/3
What's going on here?

The first line that's highlited uses
the util `createKeyedSignal` to create
a "signal" for each currency.

In the context of React-RxJS we use
the term signal for refering to external
events.

Every time that we create a signal,
we want to have an observable for listening
to those events, and an event emitter
for emitting events.

Sometimes, though, we want to partition
the signals, so that each instance has
their own signal. That's what `createKeyedSignal`
does:

it returns a function for accessing
the observable of each instance, and an
event emitter where the first argument
is going to be the key of each instance
and the second argument is going to be
the value of the observable.

Using RxJS terminology is like creating
a subject per each currency, while
also separating the Observable and
the Observer.

It sound a lot more complicated than
it actually is.

In this case `onRateChange` is
an event emitter that receives 2
arguments: the currency (which is the key),
and the number, which is the payload.

Then `rateChange$`, is a function that
receives the currency as an argument
and it returns an observable of numbers
for that currency.

The nice thing about bind is that
we can also use it with with
functions that return observables
like `rageChange$`.

Let's wire this up...
```

```jsx 15:19 file="./codeblocks/react-rxjs/03_1exchangeCurrencies.tsx"
```

```notes
Now let's replace rate with our hook
and plug the `onRateChange` event-emitter
into the `onChange` of `NumberInput`
```

```diff 21:31
```

```notes
Let's make sure that this works.

It does! Also notice how the only
rows that are re-rendering are the
ones that are being updated.

Now, let's wire up the Orders:
```

```jsx 23,30:32 file="./codeblocks/react-rxjs/03_2exchangeCurrencies.tsx"
```

```notes checkout:react-rxjs/4
First we create a hook for accessing
the ids of the orders.

We are using the same trick that we
used for wiring up the currencies.

Then latter, when we implement
the functionality for adding orders,
we will replace this EMPTY stream
with on observable of orderIds.

Next we create a keyed signal
for the priceChange and another one
for the currencyChange.

and finally we use bind for creating
the observable of each order.

I love the fact that on RxJS 7 we can
pass Objects of streams to `combineLatest`!

Notice that this time we are not
using a default value with `bind`. The
main implication of not passing the default
value to bind is that we have to make
sure that we are subscribed to the
underlying observable before render.

There are many different ways of accomplishing
that, as we will see in just a moment.
```

```jsx 22:36 file="./codeblocks/react-rxjs/04_1orderLinePriceCurrency.tsx"
```

```notes
Let's wired up the Orders component.
```

```diff 102:111
```

```notes
We grab the ids from the `useOrderIds`
and now we only pass the id to the OrderLine
component.

Also, we are using `Subscribe` to ensure
that the subscription to the underlying 
stream exists before the Orderline component
renders.

Remember, this is only necessary b/c the
`useOrder` hook was created with a bind
that didn't have a default value.

Later we will see that there is a more
convenient way of accomplishing the same.
```

```jsx 103,107:109 file="./codeblocks/react-rxjs/04_2orderLinePriceCurrency.tsx"
```

```notes
moving on into the Orderline component...
```

```diff 87:100
```

```notes
First notice how now it only receives
the id, and then we use the `useOrder`
hook to access the order with this id.

We are also plugging the onPriceChange
and the onCurrencyChange, that's it.

Let's make sure that this works...

Nice!

Time to wire up the baseCurrencyPrice...
```

```jsx 87,88,95:97,103:105 file="./codeblocks/react-rxjs/04_3orderLinePriceCurrency.tsx"
```

```notes
Notice how the order$ stream is fact the
combination of the price and the currency
stream...

So, we could also create a rate$ stream
for theselected currency, and then combine
it with the that the price stream to obtain
a baseCurrencyPrice stream.

So, let's do that.
```

```diff 28:36
```

```notes checkout:react-rxjs/5
First we define the rate$ stream,
which listens to the currency$ stream
and every time that it emits it's going
going to switchMap to the currencyRate$
stream of this currency.

Keep in mind that the streams returned
by bind are replayable.

Now we can combine the rate with the
price stream, so that whenever one 
of them emits the baseCurrencyPrice
gets recomputed.

Now let's use this stream to add the
new baseCurrencyPrice property to the order.

That's it, now let's use it.
```

```jsx 18,34:37,42 file="./codeblocks/react-rxjs/05_1orderLineBaseCurrency.tsx"
```

```notes
we replace the hardcoded value with
the new property and done!
```

```diff 116
```

```notes
let's try it out!

Notice that it never get re-renders
for unrelated things.

If we change the price of a currency
that's not being used, nothing else
get's re-rendered.
```

```jsx 116 file="./codeblocks/react-rxjs/05_2orderLineBaseCurrency.tsx"
```

```notes checkout:react-rxjs/6
Now let's make sure that we can add new
orders.

Remember how we said that we would be
using an EMPTY stream until we implemented
this functionality?

Well, now let's replace that stream
with a stream that emits a list
with a new ID every time that the
user clicks the add button.
```

```diff 24
```

```notes
For doing that we will create a signal.
Not a keyed-signal, but a signal.

This is really just a way of separating
the Observable from the observer of the
underlying Subject.

And then every time that the addOrder$
stream emits, we map that to a new ID
and the we scan it to add that ID
to the latest list of ids.

Also, we need to make sure that the
initialOrder that's defined insde
the order$ stream, gets a random-order
if the id is not one of the initial ones.
```

```jsx 25:33,39 file="./codeblocks/react-rxjs/06_1addOrder.tsx"
```

```notes
Now lets wire up the button with the
onAddOrder emitter that we got when
we created the signal and that's it.
```

```diff 153
```

```notes
notice that this time we don't have
to create a new component for the AddButton.

Let's make sure that this works...
```

```jsx 153 file="./codeblocks/react-rxjs/06_2addOrder.tsx"
```

```notes
The last thing that we have to do
wire up is the total-base-ccy-price.

We need to take every base-currency-price
from each order and add it.

In other words, we new to somehow
combine the stream of orderIds
with each stream of orders.

React-RxJS/utils provides a handy
helper for that named `combineKeys`
```

```diff 27,51
```

```notes checkout:react-rxjs/7
`combineKeys` takes a stream of ids as
the first argument, and a factory of
streams as the second argument and returns
a stream that emmits a Map of values
every time that one of the values of the Map
changes, or any time that entries of the
map changes.

So, we combine the stream of orderIds$
with the stream of baseCurrencyPrices,
and then we add those values together.

Also, notice how again we are using `bind`
without providing a default value.

Meaning that we have to make sure that
we are subscribed to the total$ stream
before the component that it's going
to render the total gets rendered.

Again, there are different ways of doing
that, but the most straightforward
is to use Subscribe. Also, since
the total$ stream already subscribes
itself to all the order$ streams,
we will be able to get rid of the
previous Subscribe that we were
using inside the Orders component.

Let's finish this...
```

```jsx 27,55:58 file="./codeblocks/react-rxjs/07_1Total.tsx"
```

```notes
Here let's use the `useTotal` hook.
```

```diff 149:152
```

```jsx 150 file="./codeblocks/react-rxjs/07_2Total.tsx"
```

```notes
Then let's use the Subscribe component
in the root component.
```

```diff 155,164
```

```notes
This would be the equivalent to our
provider.
```

```jsx 155,166 file="./codeblocks/react-rxjs/07_3Total.tsx"
```

```notes
now we won't be neededing this Subscribe
anymore, so let's remove it.

And we are done, everything should be working
perfectly fine.
```

```diff 141:143
```

```jsx 141 file="./codeblocks/react-rxjs/07_4Total.tsx"
```

```notes
One last thing, though, we can see how
only those components that need to rerender
get re-rendered... Except when we add a new
order, that all the orders get re-rendered,
let's make sure that doesn't happen:
```

```notes
using `memo` here should do it.

Let's see... perfect!

Now let's have a quick perf comparisson.
```

```diff 110
```

```notes checkout:react-rxjs/8
perf
```

```jsx 111 file="./codeblocks/react-rxjs/08_perf.tsx"
```

</NotesCodeSurfer>

---

<CodeSurferColumns themes={[vsDark, github]}>

<Step>

```jsx file="./codeblocks/react/01_startingpoint.tsx"
```

```jsx file="./codeblocks/react-rxjs/01_startingpoint.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/10_calculateTotal.tsx"
```

```jsx file="./codeblocks/react-rxjs/08_perf.tsx"
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns themes={[vsDark, github]}>

<Step>

```jsx file="./codeblocks/react/01_startingpoint.tsx"
```

```jsx file="./codeblocks/react-rxjs/01_startingpoint.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/02_4currencyContext.tsx"
```

```jsx file="./codeblocks/react-rxjs/02_3useCurrencies.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/03_exchangeRate.tsx"
```

```jsx file="./codeblocks/react-rxjs/03_2exchangeCurrencies.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/04_orderLinePrice.tsx"
```

```jsx file="./codeblocks/react-rxjs/04_3orderLinePriceCurrency.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/07_orderLinePrice.tsx"
```

```jsx file="./codeblocks/react-rxjs/05_2orderLineBaseCurrency.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/09_addOrderButton.tsx"
```

```jsx file="./codeblocks/react-rxjs/06_2addOrder.tsx"
```

</Step>

<Step>

```jsx file="./codeblocks/react/10_calculateTotal.tsx"
```

```jsx file="./codeblocks/react-rxjs/08_perf.tsx"
```

</Step>

</CodeSurferColumns>
